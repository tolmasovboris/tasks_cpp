В этой задаче вам предлагается реализовать аналог еще одного из часто используемых классов стандартной библиотеки - умного указателя с разделяемым владением, а именно shared\_ptr, и сопутствующих ему классов.

Напишите шаблонный класс SharedPtr<T> - упрощенный аналог std::shared\_ptr<T> из C++11. Должны быть реализованы следующие методы (за подробным описанием того, что должны делать эти методы, можно обращаться к cppreference):

-   Конструктор от C-style указателя. Должно быть можно сконструироваться как от указателя на T, так и от указателя на наследника T.
    
-   Конструктор копирования, конструктор перемещения, операторы присваивания, деструктор. Умный указатель на родителя должно быть можно проинициализировать умным указателем на наследника, к оператору присваивания это тоже относится.
    
-   Метод use\_count, возвращающий количество SharedPtr’ов, указывающих на тот же объект сейчас.
    
-   Метод reset от C-style указателя.
    

Реализуйте также функции создания SharedPtr из аргументов конструктора T:

-   Функцию makeShared, которая бы позволяла создавать SharedPtr минуя вызов new, сразу из аргументов конструктора T. Эта функция должна лишь 1 раз обращаться к new. Не забудьте, что аргументы надо перемещать, а не копировать, если они были rvalue.
    
-   Функцию allocateShared, которая делает то же, что и makeShared, но использует данный аллокатор вместо обращения к new. Этот же аллокатор впоследствии должен быть использован для уничтожения и освобождения памяти как под сам объект, так и под внутренние сущности SharedPtr.
    

Кроме того, нужно поддержать нестандарный Deleter и нестандартный аллокатор:

-   Конструктор от (Y\*, Deleter), где Y есть либо T, либо наследник T, а Deleter - это класс, в котором присутствует оператор ()(Y\* ptr). Этот оператор должен быть вызван вместо уничтожения объекта под SharedPtr’ом (освобождение памяти из-под объекта в таком случае делать тоже не надо).
    
-   Конструктор от (Y\*, Deleter, Alloc), где Alloc - пользовательский аллокатор. Этот аллокатор должен быть использован для создания и удаления всех тех внутренних сущностей в динамической памяти, которые нужны для работы самого SharedPtr. При этом Deleter должен работать как описано выше, то есть аллокатор не должен применяться к уничтожению и освобождению ptr.
    
-   Ни Deleter, ни Allocator не должны быть шаблонными параметрами самого класса shared\_ptr. (Подсказка: используйте идиому type erasure, чтобы обращаться к ним из shared\_ptr).
    
-   Если при смерти SharedPtr<T> обнаруживает, что нужно уничтожить объект, но объект был типа U, где U - наследник T, то нужно это учесть. Объект должен быть уничтожен как U, а не как T.
    
-   Использовать функции makeShared или allocateShared с нестандартным Deleter нельзя. Также не нужно делать конструктор от (Y\*, Alloc) без нестандартного Deleter.
    
-   Нужно поддержать aliasing конструктор, принимающий другой SharedPtr, а также C-style указатель. Наш SharedPtr должен разделять владение вместе с переданным SharedPtr’ом, но get() от нашего SharedPtr должно возвращать тот C-style pointer, который нам передали вторым параметром. Этот конструктор нужен, например, чтобы корректно работали функции static\_pointer\_cast, dynamic\_pointer\_cast и т.п..
    

Реализуйте также класс WeakPtr<T>. Должно быть поддержано следующее:

-   Конструктор от SharedPtr<U>, где U - либо T, либо наследник T.
    
-   Конструкторы копирования и перемещения, деструктор, операторы присваивания. Умный указатель на родителя должно быть можно проинициализировать умным указателем на наследника, к оператору присваивания это тоже относится.
    
-   Метод expired для проверки, не сдох ли еще объект под этим указателем.
    
-   Метод lock для получения SharedPtr на объект под данным WeakPtr’ом, если этот объект еще не сдох. (Для этого вам придется написать специальный приватный конструктор SharedPtr’а.)
    

Реализуйте также класс EnableSharedFromThis<T>. Он должен иметь публичный метод shared\_from\_this, возвращающий SharedPtr<T>. Класс EnableSharedFromThis<T> нужен для того, чтобы из методов объектов T уметь возвращать SharedPtr на текущий объект. Чтобы тип T позволял так делать, он должен быть унаследован от EnableSharedFromThis<T>. Для поддержки такого поведения вам, вероятно, потребуется слегка усложнить код конструкторов SharedPtr.
