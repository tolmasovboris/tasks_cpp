В этой задаче запрещено пользоваться какими-либо стандартными контейнерами. Выделения памяти нужно делать вручную. Разрешается подключать только <iostream> и <cstring> (можно подключить <algorithm> для использования std::fill и std::copy).

Напишите класс String - упрощенный аналог библиотечного std::string. Необходимо поддержать следующий функционал:

-   Конструктор от C-style строки (const char\*).
    
-   Конструктор от двух параметров: число n и символ c - создает строку из n копий символа c.
    
-   Конструктор по умолчанию, копирующий конструктор и оператор присваивания. Оператор присваивания должен корректно обрабатывать присваивание самому себе.
    
-   Оператор ==, позволяющий проверять строки на совпадение, оператор !=, а также операторы < > <= >= для лексикографического сравнения строк.
    
-   Квадратные скобки, корректно работающие как для константных, так и для неконстантных строк.
    
-   Метод length(), возвращающий размер строки. А также методы size() и capacity(), возвращающие соответственно размер и текущую емкость. Терминирующий символ 0 ни там, ни там не учитывается.
    
-   Методы push\_back(char) и pop\_back(). Амортизированное время работы push\_backдолжно быть O(1). Метод pop\_back должен работать за гарантированное O(1), то есть не перевыделять память.
    
-   Методы front() и back(), возвращающие ссылку на начальный и на последний символы строки соответственно. Должны корректно работать и для константных, и для неконстантных строк.
    
-   Оператор +=, позволяющий добавить к строке символ или другую строку. Добавление символа должно работать за амортизированное O(1).
    
-   Оператор +, позволяющий складывать строки с символами, символы со строками и строки со строками.
    
-   Методы find(substring) и rfind(substring), позволяющие найти самое левое и самое правое вхождение подстроки substring в данную строку. Возвращают индекс найденного вхождения. Если вхождений не найдено, нужно вернуть length() (фиктивный индекс).
    
-   Метод substr(start, count), возвращающий подстроку начиная с индекса start и состоящую из count символов.
    
-   Метод empty(), проверяющий, пуста ли строка. Метод clear(), позволяющий очистить строку. В методе clear делается только обнуление размера, но не освобождение памяти.
    
-   Метод shrink\_to\_fit(), освобождающий лишнюю использованную память.
    
-   Операторы вывода в поток « и ввода из потока ».
    
-   Метод data(), возвращающий указатель на начало строки. Корректно должен работать как для константных, так и для неконстантных строк.
    

Дополнительные замечания:

-   Строка должна заканчиваться символом с кодом 0. (Стандартный std::string тоже обладает этим свойством.) Это нужно, чтобы в случае использования data() можно было корректно работать с полученной сишной строкой.
    
-   Количество вызовов new нужно стараться свести к минимуму. В частности, в операторе += нельзя добавлять символ за символом, надо сразу выделить память на всю добавляемую строку. Аналогично в методе substring. В операторе присваивания, если текущая строка длиннее присваиваемой, стоит обойтись без перевыделения памяти.
    
-   Для заполнения строки символами, а также для копирования строк не надо использовать цикл с поэлементным присваиванием. Надо использовать memset и memcpy, а еще лучше – std::fill и std::copy.
    

В вашем файле должна отсутствовать функция main()main(), а сам файл должен называться string.hstring.h. В качестве компилятора необходимо указывать MakeC++17MakeC++17. Ваш код будет вставлен посредством команды #include "string.h" в программу, содержащую тесты; вследствие этого код необходимо отправлять в файле со строго соответствующим именем!
