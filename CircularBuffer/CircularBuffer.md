Ваша задача: реализовать циклический (a.k.a. кольцевой или круговой) буфер `CircularBuffer`. Это не стандартный контейнер `STL`, но он, скажем, есть в [библиотеке `Boost`](https://www.boost.org/doc/libs/master/doc/html/circular_buffer.html), однако, ваш буфер будет несколько отличаться.

С точки зрения функционала, `CircularBuffer` имеет интерфейс `deque` (не `std::deque`, а просто контейнера с возможностью быстрой вставки и удаления как из начала, так и из конца). При этом буфер имеет фиксированную, заданную в момент его конструирования, вместимость.

## Вместимость

Ваш `CircularBuffer` должен иметь 2 шаблонных аргумента: тип хранимых значений `typename T` и `std::size_t Capacity = DYNAMIC_CAPACITY` (где `DYNAMIC_CAPACITY` равна `std::numeric_limits<std::size_t>::max()`). Пользователь, если ему известна вместимость буфера в компайл тайме, может указать её как шаблонный аргумент `Capacity`, иначе она будет равна `DYNAMIC_CAPACITY`, что означает, что вместимость известна лишь в рантайме.

Возникают 2 разных случая, в которых ваш `CircularBuffer` должен вести себя по-разному:

1.  Если `Capacity == DYNAMIC_CAPACITY`, то:
    
    -   Буфер должен аллоцироваться в динамической памяти.
        
    -   Известная лишь в рантайме вместимость хранится полем.
        
2.  Если же `Capacity != DYNAMIC_CAPACITY`, то:
    
    -   Буфер должен создаваться на стеке, вы не должны делать никаких запросов на аллокацию динамической памяти.
        
    -   Запрещается вместимость хранить полем.
        

Само собой, вы не должны дважды полностью реализовывать `CircularBuffer` под случаи, когда вместимость известна в компайл тайме и когда нет. Это бы влекло наличие огромного кол-ва копипасты. Придумать, как обойтись здесь без неё - часть вашей задачи.

Если понадобится, в этой задаче можно использовать `std::array`. Другие стандартные контейнеры использовать нельзя.

## Итераторы

Должен быть внутренний тип `iterator` (с маленькой буквы, в лучших традициях `STL`). Этот тип, помимо очевидного, должен поддерживать:

1) Инкремент, декремент

2) Сложение с целыми числами

3) Сравнение `<` `>` `<=` `>=` `==` `!=`

4) Взятие разности двух итераторов

5) Разыменование (унарная звёздочка `*`), результатом является `T&`

6) Оператор `->`, результатом является `T*`

Также должен быть константный итератор `const_iterator`. Отличие его от обычного `iterator` в том, что он не позволяет менять лежащий под ним элемент. Конверсия (в том числе неявная) неконстантного итератора в константный допустима, обратно - нет.

Реализовать константный итератор надо так, чтобы его код не являлся копипастой кода обычного `iterator`.

При этом, если `Capacity != DYNAMIC_CAPACITY`, то хранить в итераторе вместимость буфера полем нельзя.

Также нужно реализовать реверс-итераторы: `reverse_iterator` и `const_reverse_iterator`.

Хранить в итераторе указатель на сам объект `CircularBuffer` нельзя: разыменование итератора должно требовать лишь одного разыменования указателя!

При реализации итератора вам может быть полезен стандартный класс `std::span`, можете им воспользоваться.

## Методы

При реализации методов можете считать, что вместимость буфера всегда положительна (т.е. отдельно обрабатывать случай нулевой вместимости не обязательно).

Полный список методов:

1.  Конструкторы:
    
    -   если `Capacity == DYNAMIC_CAPACITY`:
        
        Должен быть конструктор, принимающий `std::size_t capacity`, не должно быть конструктора по умолчанию.
        
        CircularBuffer<int> buffer1{32}; _// OK_
        
        CircularBuffer<int> buffer2{}; _// Не OK, это не должно даже компилироваться, пользователь не задал вместимость_
        
        Должен быть конструктор копирования от другого буфера такого же типа и оператор присваивания.
        
    -   если `Capacity != DYNAMIC_CAPACITY`:
        
        Должен быть как конструктор по умолчанию, так и конструктор, принимающий `std::size_t capacity`. В обоих случаях вместимость задаётся шаблонным аргументом `Capacity`, во втором случае аргумент `capacity` должен быть рабен `Capacity`, иначе нужно кидать исключение `std::invalid_argument`.
        
        CircularBuffer<int, 32> buffer1{}; _// OK_
        
        CircularBuffer<int, 32> buffer2{32}; _// OK_
        
        CircularBuffer<int, 32> buffer3{42}; _// Не OK, должно выкинуться исключение std::invalid\_argument_
        
        Должны быть конструктор копирования и оператор присваивания от другого буфера такого же типа (т.е. такой же вместимости в данном случае).
        
        CircularBuffer<int, 32> buffer1{};
        
        CircularBuffer<int, 32> buffer2{buffer1}; _// OK_
        
        CircularBuffer<int, 42> buffer3{buffer1}; _// Не OK, это не должно даже компилироваться_
        
        buffer1 = buffer2; _// OK_
        
        buffer1 = buffer3; _// Не OK, это не должно даже компилироваться_
        
2.  Методы `push_back`, `push_front`. Должны работать за `O(1)`. В случае, если буфер уже полон, то должно происходить затирание краевого значения (в случае с `push_back` - первого (переднего), с `push_front` - последнего (заднего)).
    
3.  Методы `pop_back`, `pop_front`. Должны работать за `O(1)`.
    
4.  Методы `size()`, `capacity()`, `empty()`, `full()` (последний возвращает `true` если и только если `CircularBuffer` полностью заполнен).
    
5.  Обращение по индексу: квадратными скобками (без проверок выхода за границу) и `at` (кидающее `std::out_of_range`). Должно работать за `O(1)`.
    
6.  Методы `begin`, `cbegin`, `end` и `cend`, возвращающие неконстантные и константные итераторы на начало и на “элемент после конца” контейнера соответственно. Если сам контейнер константный, то методы `begin` и `end` тоже возвращают константные итераторы. Декремент `end` должен давать итератор на последний элемент, вычитание целых чисел из `end` также должно корректно работать и давать итераторы на соответствующие элементы.
    
7.  Методы `rbegin`, `rend`, `crbegin`, `crend`.
    
8.  Метод `swap` с другим `CircularBuffer`\-ом того же типа. Важная деталь: если `Capacity == DYNAMIC_CAPACITY` и вы делаете `swap` двух `CircularBuffer`\-ов, то уже существовавшие до этого итераторы должны продолжать указывать на те же элементы, на которые указывали.
    
9.  Метод `insert(iterator, const T&)`, делающий вставку значения перед элементом, на который указывает итератор. Элемент, на который указывает итератор, и все остальные правее его сдвигаются на один вправо. При отсутствии свободного места затирается первый элемент в контейнере. Если свободное место отсутствует и итератор указывает на первый элемент, то вставка не происходит, содержимое контейнера остаётся как было. Метод `insert` работает линейное время.
    
10.  Метод `erase(iterator)`, удаляющий элемент из контейнера по итератору. Все элементы справа сдвигаются на один влево, удаление работает линейное время.
     

## Исключения

Все методы, кроме `insert` и `erase`\*, должны быть строго безопасны относительно исключений. Это значит, что в случае исключения в конструкторе или операторе присваивания типа `T` во время выполнения какого-либо метода `CircularBuffer`, последний должен вернуться в исходное состояние, которое было до начала выполнения метода, и пробросить исключение наверх в вызывающий код.

(\*) В случае, когда `Capacity != DYNAMIC_CAPACITY`, к методам, которые не должны быть строго безопасны относительно исключений, прибавляются `operator=` и `swap`.

## Последняя мелочь

В вашем файле должна отсутствовать функция `main`, а сам файл должен называться `circular_buffer.h`. Ваш код будет включен посредством `#include` в программу, содержащую тесты.
